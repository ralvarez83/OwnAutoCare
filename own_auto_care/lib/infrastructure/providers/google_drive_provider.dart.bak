
import 'dart:async';
import 'dart:convert';

import 'package:google_sign_in/google_sign_in.dart';
import 'package:googleapis/drive/v3.dart' as drive;
import 'package:googleapis_auth/googleapis_auth.dart' as gauth;
import 'package:http/http.dart' as http;

import '../../domain/repositories/repositories.dart';

import 'package:own_auto_care/secrets.dart';

class GoogleDriveProvider implements CloudStorageProvider {
  final GoogleSignIn _googleSignIn;
  http.Client? _client;
  final String clientId;
  final List<String> scopes;
  String? _appFolderId;
  static const String _appFolderName = 'OwnAutoCare';

  GoogleDriveProvider({GoogleSignIn? googleSignIn, this.clientId = googleClientId, this.scopes = const ['https://www.googleapis.com/auth/drive.file']}) : _googleSignIn = googleSignIn ?? GoogleSignIn(
        scopes: scopes,
        clientId: clientId,
      );

  Future<void> authenticate() async {
    if (_client != null) {
      return;
    }
    try {
      final googleUser = await _googleSignIn.signIn();
      if (googleUser == null) {
        throw 'Sign in aborted by user';
      }
      
      final googleAuth = await googleUser.authentication;
      if (googleAuth.accessToken == null) {
        throw 'Access token is null';
      }

      final credentials = gauth.AccessCredentials(
        gauth.AccessToken(
          'Bearer',
          googleAuth.accessToken!,
          DateTime.now().toUtc().add(const Duration(hours: 1)), // Assuming 1 hour expiry
        ),
        null, // No refresh token from google_sign_in
        _googleSignIn.scopes,
      );

      _client = gauth.authenticatedClient(http.Client(), credentials);

    } catch (e) {
      // Handle error
      rethrow;
    }
  }

  Future<void> authenticateWithToken(String token) async {
    if (_client != null) {
      return;
    }
    try {
      final credentials = gauth.AccessCredentials(
        gauth.AccessToken(
          'Bearer',
          token,
          DateTime.now().toUtc().add(const Duration(hours: 1)), // Assuming 1 hour expiry
        ),
        null, // No refresh token from google_sign_in
        _googleSignIn.scopes,
      );

      _client = gauth.authenticatedClient(http.Client(), credentials);

    } catch (e) {
      // Handle error
      rethrow;
    }
  }

  Future<GoogleSignInAccount?> getCurrentUser() async {
    return await _googleSignIn.signInSilently();
  }

  Future<void> logout() async {
    await _googleSignIn.disconnect();
    await _googleSignIn.signOut();
    _client = null;
    _appFolderId = null;
  }

  @override
  Future<void> ensureSetup() async {
    await authenticate();
    final driveApi = drive.DriveApi(_client!);
    
    // Check if app folder exists
    final appFolder = await _findAppFolder(driveApi);
    if (appFolder != null) {
      _appFolderId = appFolder.id;
      return;
    }

    // Create app folder if it doesn't exist
    final folderMetadata = drive.File()
      ..name = _appFolderName
      ..mimeType = 'application/vnd.google-apps.folder'
      ..parents = ['root'];
    
    final folder = await driveApi.files.create(folderMetadata);
    _appFolderId = folder.id;
    
    // Initialize carcare.json with empty structure
    await writeRootMetadata({
      'vehicles': [],
      'settings': {
        'currency': 'EUR',
        'locale': 'es-ES'
      }
    });
  }

  Future<drive.File?> _findAppFolder(drive.DriveApi driveApi) async {
    final query = "name = '$_appFolderName' and mimeType = 'application/vnd.google-apps.folder' and trashed = false";
    final result = await driveApi.files.list(q: query, spaces: 'drive', $fields: 'files(id, name)');
    if (result.files?.isEmpty ?? true) {
      return null;
    }
    return result.files!.first;
  }

  @override
  Future<JsonMap> readRootMetadata() async {
    await authenticate();
    if (_appFolderId == null) {
      await ensureSetup();
    }

    final api = drive.DriveApi(_client!);
    final metadataFile = await _getMetadataFile(api);
    if (metadataFile == null) {
      // If file doesn't exist, create it with initial structure
      final initialData = {
        'vehicles': [],
        'settings': {
          'currency': 'EUR',
          'locale': 'es-ES'
        }
      };
      await writeRootMetadata(initialData);
      return initialData;
    }

    try {
      final content = await api.files.get(
        metadataFile.id!, 
        downloadOptions: drive.DownloadOptions.fullMedia
      ) as drive.Media;
      final jsonStr = await utf8.decodeStream(content.stream);
      return json.decode(jsonStr);
    } catch (e) {
      // If there's an error reading the file, return empty initial data
      return {
        'vehicles': [],
        'settings': {
          'currency': 'EUR',
          'locale': 'es-ES'
        }
      };
    }
        metadataFile.id!, 
        downloadOptions: drive.DownloadOptions.fullMedia
      ) as drive.Media;
      final jsonStr = await utf8.decodeStream(content.stream);
      return json.decode(jsonStr);
  }

  @override
  Future<void> writeRootMetadata(JsonMap data) async {
    await authenticate();
    if (_appFolderId == null) {
      await ensureSetup();
    }

    final driveApi = drive.DriveApi(_client!);
    final file = await _getMetadataFile(driveApi);
    final content = json.encode(data);
    final media = drive.Media(
      Stream.value(utf8.encode(content)), 
      content.length,
      contentType: 'application/json'
    );

    if (file == null) {
      final newFile = drive.File()
        ..name = 'carcare.json'
        ..parents = [_appFolderId!]
        ..mimeType = 'application/json';
      await driveApi.files.create(newFile, uploadMedia: media);
    } else {
      await driveApi.files.update(drive.File(), file.id!, uploadMedia: media);
    }
  }

  Future<drive.File?> _getMetadataFile(drive.DriveApi driveApi) async {
    if (_appFolderId == null) {
      await ensureSetup();
    }

    final query = "name = 'carcare.json' and '${_appFolderId!}' in parents and trashed = false";
    final files = await driveApi.files.list(
      q: query,
      spaces: 'drive',
      $fields: 'files(id, name)',
    );

    if (files.files?.isEmpty ?? true) {
      return null;
    }
    return files.files!.first;
  }

  @override
  Future<List<CloudItem>> listRecords(String vehicleId) async {
    await authenticate();
    // Implementation to list records
    throw UnimplementedError();
  }

  @override
  Future<JsonMap> readRecord(String path) async {
    await authenticate();
    // Implementation to read a record
    throw UnimplementedError();
  }

  @override
  Future<void> writeRecord(String path, JsonMap data) async {
    await authenticate();
    // Implementation to write a record
    throw UnimplementedError();
  }

  @override
  Future<void> deleteRecord(String path) async {
    await authenticate();
    // Implementation to delete a record
    throw UnimplementedError();
  }

  @override
  Future<Uri> getAttachmentLink(String path) async {
    await authenticate();
    // Implementation to get attachment link
    throw UnimplementedError();
  }
}
